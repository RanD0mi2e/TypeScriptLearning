# 接口

## 1.可选属性：	

```typescript
// 属性名后面的？表示该属性可以选择性传入
interface SquareConfig {
  color?: string;
  width?: number;
}
// 可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。
```

## 2.只读属性：

​		一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 `readonly`来指定只读属性:

```typescript
interface Point {
    readonly x: number;
    readonly y: number;
}

let p1: Point = { x: 10, y: 20 };
p1.x = 5; // error!
```

​		TypeScript具有`ReadonlyArray<T>`类型，它与`Array<T>`相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改:

```typescript
let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray<number> = a;
ro[0] = 12; // error!
ro.push(5); // error!
ro.length = 100; // error!
a = ro; // error!
```

​		`readonly` vs `const`：最简单判断该用`readonly`还是`const`的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 `const`，若做为属性则使用`readonly`。

## 3.函数类型：

​		接口除了描述对象外，还可以描述函数类型：

```typescript
// 接口
interface SearchFunc {
  (source: string, subString: string): boolean;
}

// 使用接口
let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
  let result = source.search(subString);
  return result > -1;
}

// 使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。
```

## 4.可索引的类型：

​		与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如`a[10]`或`ageMap["daniel"]`。 可索引类型具有一个 *索引签名*，它描述了对象索引的类型，还有相应的索引返回值类型。

```typescript
interface StringArray {
  [index: number]: string;
}

let myArray: StringArray;
myArray = ["Bob", "Fred"];

let myStr: string = myArray[0];
```

​		TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。

```typescript
class Animal {
    name: string;
}
class Dog extends Animal {
    breed: string;
}

// 数字索引和字符串索引同时存在时，数字类型key对应的value必须是字符串类型key对应的vaue子类型
// 因为在js中，Array类和Object类底层都是哈希表，Array类是个伪数组；
// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!
interface NotOkay {
    [x: number]: Animal;
    [x: string]: Dog;
}
```

## 5.类类型——实现接口：

​		js中实现接口和java作用基本一致，TypeScript也能够用它来明确的强制一个类去符合某种契约。

```typescript
// 可以在接口中抽象描述一个方法，在类中去实现它
interface ClockInterface {
    currentTime: Date;
    setTime(d: Date);
}

class Clock implements ClockInterface {
    currentTime: Date;
    setTime(d: Date) {
        this.currentTime = d;
    }
    constructor(h: number, m: number) { }
}
// 接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。
```

## 6.类静态部分和实例部分的区别：

​		当你操作类和接口的时候，类是具有两个类型的：`静态部分的类型和实例的类型`。当**一个类实现了一个接口**时，只对其**实例部分**进行类型检查（如果我们的class继承了interface接口，那么typescript将会对new出来这个的实例进行检查，而不会去检查class内部的constructor）。你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：

```typescript
interface ClockConstructor {
    new (hour: number, minute: number);
}

// 报错：类'Clock'错误实现接口'ClockConstructor'
class Clock implements ClockConstructor {
    currentTime: Date;
    constructor(h: number, m: number) { }
}

// 原因：因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。
```

​		使用typeScript对class进行约束与声明的步骤：				

```typescript
// 1.实例部分接口，用来约束最终创建的实例
interface StudentInterface {
  id: string
  age: number
  go():void;
}

// 2.静态部分接口，用来约束构造器声明，返回类型为实例部分接口类型
interface StudentInfoType {
  new (classId: string, code: string, age: number): StudentInterface;
}

// 3.声明用于构造对象的方法（区别于名词‘构造函数’）调用静态部分接口进行实例化对象操作
// 通过调用静态部分接口，来进行接口约束
function createStudent(studentInfo: StudentInfoType, classId: string, code:string, age: number): StudentInterface {
    return new studentInfo(classId, code, age);
}

// 4.声明class，声明时实现 实例部分接口
class StudentItem implements StudentInterface {
  id: string;
  age: number;

  // constructor构造器，内部声明在createStudent中被约束
  constructor(classId: string, code: string, age: number){
    this.id = classId + "" + code
    this.age = age
  }
  go(){
    console.log('gogogo')
  }
}

// 5.传入构造函数来实例化对象，在createStudent中将后续参数通过constructor构造器挂载在实例上
let 小明 = createStudent(StudentItem, '05', '33', 12)
console.log(小明)

// 写法二：
interface StudentInterface {
  id: string
  age: number
  go():void;
}

interface StudentInfoType {
  new (classId: string, code: string, age: number): StudentInterface;
}

let createStudent: StudentInfoType = class StudentItem implements StudentInterface{
  id: string;
  age: number;
  constructor(classId: string, code: string, age: number){
    this.id = classId + "" + code
    this.age = age
  }
  go(){
    console.log('gogogo')
  }
}

let 小明 = new createStudent('05', '33', 12)
console.log(小明)
```

## 7.继承接口：

​		接口可以被类继承，也可以接口之间相互继承，这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。

## 8.混合类型：

​		一个对象可以同时作为函数和对象使用，并拥有额外的类型。

```tsx
interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}

// JS中函数本质上也是一个对象
function getCounter(): Counter {
    let counter = <Counter>function (start: number) { };
    counter.interval = 123;
    counter.reset = function () { };
    return counter;
}

let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;
```

## 9.接口继承类：

​		当接口继承了一个类类型时，它会继承类的成员但不包括其实现（java中不允许接口继承类）。就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了**一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现**（implement）。